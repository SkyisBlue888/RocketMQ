# 前言

本篇总结一条Remoting协议同步发送的普通消息从生产者客户端经网络传输到达Broker服务端并存储落盘的全过程。

按顺序涉及：Client、Remoting、Broker、Store 4个模块，这里会对各模块所涉及的部分做阅读总结。

# Message数据结构

![Message继承体系.drawio](../images/Message继承体系.drawio.png)

# Client

#### 类关系

![Remoting协议生产者类图.drawio](../images/Remoting协议生产者类图.drawio.png)


#### 生产者启动

DefaultMQProducer.start
- DefaultMQProducerImpl.start
  - MQClientManager.getInstance().getOrCreateMQClientInstance：MQClientInstance是客户端单例实例，由进程内所有Producer、Consumer共享，统一维护连接通道等资源。
  - MQClientInstance.registerProducer：按ProducerGroup将当前Producer反向注册至MQClientInstance，避免ProducerGroup重复。
  - MQClientInstance.start
    - MQClientAPIImpl.start：
      - RemotingClient.start：启动RemotingClient。
    - MQClientInstance.startScheduledTask：启动调整线程池、持久化消费offset、发送心跳、清理离线Broker、刷新路由信息、刷新namesrv地址等定时任务。
    - PullMessageService.start：启动消息拉取服务，用于消费场景。
    - RebalanceService.start：启动重平衡服务，用于消费场景。
    - DefaultMQProducerImpl.start：启动CLIENT_INNER_PRODUCER_GROUP生产者组的内部默认生产者，用于消息回发等场景。
  - MQFaultStrategy.startDetector
    - LatencyFaultTolerance.startDetector：启动Broker故障探测服务，帮助生产者屏蔽发送失败的Broker。
  - MQClientInstance.sendHeartbeatToAllBrokerWithLock：立即向所有Broker发送心跳包。
#### 路由获取

DefaultMQProducerImpl.initTopicRoute

- DefaultMQProducerImpl.tryToFindTopicPublishInfo
  - MQClientInstance.updateTopicRouteInfoFromNameServer
    - MQClientAPIImpl.getTopicRouteInfoFromNameServer：从NameSrv获取Topic路由数据。
    - MQClientInstance.topicRouteData2EndpointsForStaticTopic：将Topic路由数据转换成Endpoints供[静态Topic](https://github.com/apache/rocketmq/wiki/RIP-21-logical-queue-abstraction-for-static-topic-and-fast-scale-out)使用。
    - MQClientInstance.topicRouteData2TopicPublishInfo：将Topic路由数据转换成Topic发布信息供生产者使用。
    - MQClientInstance. topicRouteData2TopicSubscribeInfo：将Topic路由数据转换成Topic订阅信息供消费者使用。

#### 消息发送

DefaultMQProducer.send
- DefaultMQProducerImpl.sendDefaultImpl
  - DefaultMQProducerImpl.tryToFindTopicPublishInfo：尝试找到目标Topic的发布信息。
  - DefaultMQProducerImpl.selectOneMessageQueue：按故障容错策略挑选一个可用队列。
  - DefaultMQProducerImpl.sendKernelImpl：执行发送消息前的钩子函数，组装SendMessageRequestHeader。
    - MQClientAPIImpl.sendMessage：组装RemotingRequest。
      - MQClientAPIImpl.sendMessageSync：调用RemotingClient。
        - RemotingClient.invokeSync：发送Remoting请求。

#### 高可用

- 重试机制：生产者在消息发送时如果出现失败，默认会在发送超时时间范围内立即重试 2 次。
- 故障规避机制：如果重试的消息仍发往同一个 Broker，发送大概率还是会失败，所以在重试挑选队列时会尽量避开刚刚发送失败的 Broker。
  - 可以通过配置故障延迟机制来指定是在本次消息发送时暂时避开发送失败的 Broker，还是在之后一段时间都避开该 Broker

# Remoting

#### 写入请求

RemotingClient.invokeSync：

- RemotingClient.invokeSyncImpl：
  - NettyRemotingAbstract.invokeSyncImpl：获取Future后直接调用get并同步阻塞等待返回响应。
    - NettyRemotingAbstract.invoke0：invoke最终实现。
      - Semaphore.tryAcquire：尝试获取信号量，通过信号量来限制正在进行的异步请求的最大数量，这保护了系统内存占用。
      - new ResponseFuture：创建ResponseFuture用于传递响应结果。
      - NettyRemotingAbstract.responseTable.put：将对应responseFuture记录至本地responseTable中，当服务端响应返回至客户端后，NettyClientHandler会取出responseFuture并将响应内容解码后填入其responseCommand字段。
      - Channel.writeAndFlush：将请求写入channel由netty框架发送至服务端。

#### 读取响应

NettyClientHandler.channelRead0：服务端返回响应后，由netty框架完成解码将触发channel read。

- NettyClientHandler.processMessageReceived：
  - NettyRemotingAbstract.processResponseCommand：
    - ResponseFuture.get：获取写入请求过程中写入缓存的responseFuture。
    - ResponseFuture.setResponseCommand：将解码完成的RemotingCommand写入对应字段。
      - NettyRemotingAbstract.executeInvokeCallback：
        - ResponseFuture.executeInvokeCallback：
          - InvokeCallback.operationOnSucceed：触发创建ResponseFuture时填入的回调函数。
            - CompletableFuture\<ResponseFuture\>.complete：将处理后的ResponseFuture填入最终future返回给请求调用方，一次完整的请求调用到此完成。

# Broker

SendMessageProcessor.processRequest：

- SendMessageProcessor.parseRequestHeader：
- SendMessageProcessor.executeSendMessageHookBefore：
- SendMessageProcessor.sendMessage：

# Store

DefaultMessageStore.putMessage：

- DefaultMessageStore.asyncPutMessage：
  - PutMessageHook.executeBeforePutMessage：
  - CommitLog.asyncPutMessage：
    - PutMessageLock.lock：加锁
    - MappedFileQueue.getLastMappedFile：获取最新commitlog对应的mappedFile。
      - MessageExtEncoder.encode：将目标messageExtBatch按消息存储协议编码后写入到一块ByteBuffer中。
    - MessageExtBatch.setEncodeBuff：将存储编码后消息的ByteBuffer存入相应字段。
    - DefaultMappedFile.appendMessage：
      - DefaultMappedFile.appendMessageInner：
        - DefaultMappedFile.appendMessageBuffer：获取mappedFile对应的ByteBuffer，此内存直接映射到磁盘文件。
        - DefaultAppendMessageCallback.doAppend：将消息最终写入ByteBuffer。
    - PutMessageLock.unlock：解锁
    - CommitLog.handleDiskFlushAndHA：
      - CommitLog.handleDiskFlush：
        - DefaultFlushManager.handleDiskFlush：按照异步、同步的刷盘策略构造刷盘请求体。
          - GroupCommitService.putRequest：
          - GroupCommitService.doCommit：在另一个刷盘线程中定时处理刷盘请求。
            - MappedFileQueue.flush：
              - MappedFileQueue.findMappedFileByOffset：按照刷盘目标offset找到对应CommitLog文件。
                - MappedFile.flush：
                  - MappedByteBuffer.force：强制将内存中的数据刷入磁盘。


