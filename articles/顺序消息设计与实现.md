# 前言

本文总结顺序消息的设计与实现，顺序指先到Broker的消息先被消费。

RocketMQ当前Topic与Queue设计下，单一Topic内只要有多个队列由多个消费者同时消费就必定存在并发消费，而并发消费是天然无序的，所以RocketMQ仅支持单队列内消息有序，并不支持Topic级多队列之间消息有序（当然也可以通过Topic级全局锁实现并发场景下的有序，但那可能极大地提升复杂性）：
- 单队列内按到达先后顺序存储生产者发送的消息。
- 单队列内按存储顺序向消费组投递消息。

按业务场景可分为分区顺序、全局顺序：
- 分区顺序：指定Topic，同一个队列内的消息有序，不同队列之间的消息不保证有序，业务可以将所有消息分组投递到不同队列。
- 全局顺序：指定Topic，所有消息严格有序；由于Broker仅支持单队列有序，顺序Topic实际只包含一个队列，并发度和性能更低。

# 生产顺序性

如需保证消息生产的顺序性，则必须满足以下条件：
- 单一生产者：同一时间仅启动一个生产者。
- 单一队列：组内有序的消息发送到同一个队列下。
- 串行发送：
  - 避免多线程下调用send：多线程下发送顺序不可预测。
  - 避免异步模式发送消息：发送异常重试时可能导致乱序。

# 消费顺序性

消息消费分为以下阶段：
- Consumer重平衡。
- Consumer从Broker拉取消息。
- Consumer消费消息。
- Consumer重试消费失败的消息。

### 重平衡

重平衡分为初始化启动、中途启停调整两种场景，需要防范乱序的主要是中途启停调整过程中，老消费者还未完成消费新消费者开始消费从而导致重复消费；防范机制采用Broker加锁，重平衡阶段涉及的锁这里称为“队列锁”。

队列锁在Broker端的实现采用一个维护在内存中的ConcurrentHashMap<String /\*ConsumerGroupName\*/, ConcurrentHashMap<MessageQueue, LockEntry>>对象，其中每个LockEntry通过ClientId唯一标识一个消费者，并且包含lastUpdateTimestamp字段默认每分钟自动过期。

另外还涉及Consumer本地维护在每个ProcessQueue内的“消费锁“，它是一种读写锁。

顺序消费重平衡过程，只列出与并发消费区别的步骤：

- RebalanceImpl.rebalanceByTopic：
  - RebalanceImpl.updateProcessQueueTableInRebalance：
    - 移除未分配的存量队列，RebalancePushImpl.removeUnnecessaryMessageQueue：
      - RebalancePushImpl.tryRemoveOrderMessageQueue：先尝试获取目标ProcessQueue“消费锁”写锁，由于写读互斥，如果移除队列时还有ConsumeRequest在消费目标队列中的消息，加写锁将失败；加写锁成功后：
        - OffsetStore.persist：确保已将目标队列的最新offset持久化。
        - OffsetStire.removeOffset：移除本地的目标队列Offset缓存。
        - RebalanceImpl.unlock：目标队列移除“队列锁”。
          - MQClientInstance.findBrokerAddressInSubscribe：找到目标队列所在Broker。
          - MQClientAPIImpl.lockBatchMQ：向Broker发送请求解锁目标队列。
    - 添加新队列：
      - RebalanceImpl.lock：目标队列加“队列锁”。
        - MQClientInstance.findBrokerAddressInSubscribe：找到目标队列所在Broker。
        - MQClientAPIImpl.lockBatchMQ：向Broker发送请求锁定目标队列。
        - 遍历processQueueTable将目标队列对应的ProcessQueue locked设置为true。
      - RebalanceImpl.createProcessQueue：创建目标队列对应ProcessQueue。
      - RebalanceImpl.computePullFromWhere：计算目标队列最新offset。
      - 将目标ProcessQueue加入processQueueTable。

### 拉取

因为RocketMQ客户端SDK和服务端通信协议保障消息按照服务端存储顺序投递，所以在单队列维度的消息从Broker被拉取/投递到Consumer本地时都是天然有序的。

由于拉取请求PullRequest存在非常多因不满足条件而推迟执行的情况，所以在最终执行PullRequest之前会再次检查“队列锁”是否已生效，否则将继续推迟执行。

### 消费

消费逻辑实现在ConsumeMessageConcurrentlyService.ConsumeRequest.run方法中，为保证顺序性：
- 整个run方法开头使用synchronized语法锁住整个方法段为避免在多线程的环境下出现并发消费。
- 调用业务消费回调函数之前，先获取ProcessQueue读锁，避免消费中途发生重平衡造成重复消费。
- 如取一批消息消费成功：
  - 如开启autoCommit，立即计算offset并提交。
  - 如未开启，待回调返回状态为COMMIT时计算offset并提交。
- 如取一批消息中途消费失败，回调返回状态SUSPEND_CURRENT_QUEUE_A_MOMENT，按如下步骤处理：
  - 计算消费重试次数是否达到最大限制。
  - 未达到最大限制，恢复该批消息在ProcessQueue中的状态后，重新提交ConsumeRequest待重新触发消费。
  - 已达到最大限制，重投至RetryTopic，直接提交offset并跳过该批消息。